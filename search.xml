<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django</title>
    <url>/2019/07/23/Django/</url>
    <content><![CDATA[<h1 id="Django-框架"><a href="#Django-框架" class="headerlink" title="Django 框架"></a>Django 框架</h1><blockquote>
<blockquote>
<p><strong>本文基于Linux环境下操作</strong></p>
</blockquote>
</blockquote>
<h2 id="MVT框架"><a href="#MVT框架" class="headerlink" title="MVT框架"></a>MVT框架</h2><ul>
<li>M：Model <strong>模型</strong>&emsp;&emsp;作用：和后台数据库进行交互。</li>
<li>V：View：<strong>视图</strong>&emsp;&emsp;&nbsp;作用：接受浏览器请求，进行处理并与模型和模板进行交互，返回应答。</li>
<li>T: Template <strong>模板</strong>&nbsp;&nbsp;&nbsp;&emsp;作用：产生html页面。<a id="more"></a>
</li>
</ul>
<hr>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol>
<li><strong>安装虚拟环境</strong>&nbsp;(仅仅只是Python环境的复制版本，并不是另一套系统)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install virtualenv  # 利用pip下载virtualenv包</span><br></pre></td></tr></table></figure></li>
<li><strong>安装虚拟环境扩展包</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install virtualenvwrapper</span><br></pre></td></tr></table></figure></li>
<li><strong>编辑家目录下面的.bashrc文件，添加下面两行。</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME&#x3D;$HOME&#x2F;.virtualenvs</span><br><span class="line">source &#x2F;usr&#x2F;local&#x2F;bin&#x2F;virtualenvwrapper.sh</span><br></pre></td></tr></table></figure></li>
<li><strong>使用下面的命令使虚拟环境生效</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure></li>
<li><strong>创建虚拟环境</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv 虚拟环境名  # 此时为Python2的解释器创建</span><br><span class="line">mkvirtualenv -p python3 bj11_py3</span><br><span class="line">workon 虚拟环境名  # 进入虚拟环境工作</span><br><span class="line">workon 空格 + 两个tab键  # 查看主机上所有的虚拟环境</span><br><span class="line">deactivate  # 退出虚拟环境</span><br><span class="line">rmvirtualenv 虚拟环境名  #删除虚拟环境</span><br></pre></td></tr></table></figure></li>
<li><strong>安装Django环境</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django&#x3D;&#x3D;1.8.2  # 注意：不能使用sudo安装，sudo会安装到真是的主机环境上，而不是虚拟环境中</span><br><span class="line">pip list  # 可以查看虚拟环境中安装了哪些python包</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">django-admin startproject 项目名称</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：创建应用必须先进入虚拟环境。</em></strong><br><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%87-1.jpg" alt="1"></p>
<h4 id="各个文件的说明"><a href="#各个文件的说明" class="headerlink" title="各个文件的说明"></a>各个文件的说明</h4><ul>
<li>_ <em>init</em> _.py:说明该项目是一个Python包</li>
<li>settings.py:项目配置文件</li>
<li>urls.py:进行url路由的配置</li>
<li>wsgi.py:web服务器和Django交互的入口</li>
<li>manage.py:项目的管理文件</li>
</ul>
<p><em>注：一个项目由多个应用组成，每个应用完成一个特定的功能，在Django中，每个模块使用一个Django应用来开发</em></p>
<p><strong>因此，接下来将了解如何创建一个应用</strong></p>
<h2 id="应用创建"><a href="#应用创建" class="headerlink" title="应用创建"></a>应用创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp 应用名称   # 创建应用时需先进入到项目目录</span><br></pre></td></tr></table></figure>

<p><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%872.jpg" alt="1"></p>
<h4 id="各个文件的说明-1"><a href="#各个文件的说明-1" class="headerlink" title="各个文件的说明"></a>各个文件的说明</h4><ul>
<li>_ <em>init_</em>.py:说明该目录是一个Python模块</li>
<li>models.py:用来写和数据库交互的功能</li>
<li>views.py:定义处理函数，称为视图函数</li>
<li>tests.py:用来写测试代码的文件</li>
<li>admin.py:网站后台管理的相关文件</li>
</ul>
<p><strong>在建立了项目与应用之后，还需要对应用进行注册，才能使该项目和该应用关联</strong></p>
<h4 id="方法：修改settings-py中的INSTALLED-APPS配置项。"><a href="#方法：修改settings-py中的INSTALLED-APPS配置项。" class="headerlink" title="方法：修改settings.py中的INSTALLED_APPS配置项。"></a>方法：修改settings.py中的INSTALLED_APPS配置项。</h4><p><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%873.jpg" alt="1"></p>
<h3 id="运行Django框架命令-在项目目录下进行"><a href="#运行Django框架命令-在项目目录下进行" class="headerlink" title="运行Django框架命令(在项目目录下进行)"></a>运行Django框架命令(在项目目录下进行)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p><strong><em>完成了上述动作之后就已经构建起了基本的Django的框架，接下来就可以向此框架中添加配置了！</em></strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2019/07/23/Django/%E6%96%97%E5%9B%BE1.jpg" alt="1"></p>
<hr>
<h2 id="ORM模型-对象——关系映射"><a href="#ORM模型-对象——关系映射" class="headerlink" title="ORM模型(对象——关系映射)"></a>ORM模型(对象——关系映射)</h2><p><strong>Django中内嵌了ORM框架，ORM的作用是将类和数据表进行关联，即只需要对类和对象进行操作就可以对数据库进行更改，并且ORM可以根据设计的类自动生成表。</strong></p>
<p><strong>注意：在应用下的model.py文件中设计模型类时，该类必须继承models.Model类</strong><br><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%874.png" alt="1"></p>
<p>如上图所示，bookinfo类继承了models.Model类，并且可以看出bookinfo有两种属性，分别是bittle和bpub_date,代表了图书的名称和出版日期。</p>
<h2 id="模型类生成表"><a href="#模型类生成表" class="headerlink" title="模型类生成表"></a>模型类生成表</h2><p><strong>刚刚说到ORM可以根据模型类自动生成表，那么要如何操作呢，接下来就来看看.</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2019/07/23/Django/%E6%96%97%E5%9B%BE2.jpg" alt="1"></p>
<ul>
<li>生成迁移文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%875.jpg.png" alt="1"></p>
<ul>
<li>执行迁移文件生成表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></li>
<li><em>生成表的默认格式：应用名_模型类名(小写)*</em></li>
<li><strong>注意：先在生成的数据库是sqlite3数据库，如果你想看到图形化的数据库界面，可以安装sqliteman，使用如下命令*</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sqliteman</span><br><span class="line">sqliteman     # 即可启动sqliteman查看图形化的sqlite数据库</span><br></pre></td></tr></table></figure>
<h4 id="pip和apt-get的区别"><a href="#pip和apt-get的区别" class="headerlink" title="pip和apt-get的区别"></a>pip和apt-get的区别</h4>这里简单介绍一下二者的区别，apt-get一般用于安装软件，而pip是Python管理包的工具，通常用于进行Python包和模块的安装</li>
</ul>
<hr>
<h2 id="通过模型类操作数据表"><a href="#通过模型类操作数据表" class="headerlink" title="通过模型类操作数据表"></a>通过模型类操作数据表</h2><p><strong>进入Python shell的命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure>

<p><em>应当先导入刚才在应用中建立的models类</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from 应用名.models import 类名</span><br></pre></td></tr></table></figure>

<p><strong>以下为在相互shell终端中演示的例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) 向booktest_bookinfo表中插入一条数据。</span><br><span class="line">    b &#x3D; BookInfo() #定义一个BookInfo类的对象</span><br><span class="line">    b.btitle &#x3D;&#39;天龙八部&#39; #定义b对象的属性并赋值</span><br><span class="line">    b.bpub_date &#x3D; date(1990,10,11) </span><br><span class="line">    b.save() #才会将数据保存进数据库</span><br><span class="line"></span><br><span class="line">2）查询出booktest_bookinfo表中id为1的数据。</span><br><span class="line">    b &#x3D; BookInfo.objects.get(id&#x3D;1)</span><br><span class="line">     </span><br><span class="line">3）在上一步的基础上改变b对应图书的出版日期。</span><br><span class="line">    b.bpub_date &#x3D; date(1989,10,21)</span><br><span class="line">    b.save() #才会更新表格中的数据</span><br><span class="line"></span><br><span class="line">4）紧接上一步，删除b对应的图书的数据。</span><br><span class="line">    b.delete() #才会删除</span><br><span class="line"></span><br><span class="line">5）向booktest_heroInfo表中插入一条数据。</span><br><span class="line">    h &#x3D; HeroInfo()</span><br><span class="line">    h.hname &#x3D; &#39;郭靖&#39;</span><br><span class="line">    h.hgender &#x3D; False</span><br><span class="line">    h.hcomment &#x3D; ‘降龙十八掌’</span><br><span class="line">    b2 &#x3D; BookInfo.objects.get(id&#x3D;2)</span><br><span class="line">    h.hbook &#x3D; b2  #给关系属性赋值，英雄对象所属的图书对象</span><br><span class="line">    h.save() </span><br><span class="line"></span><br><span class="line">6）查询图书表里面的所有内容。</span><br><span class="line">    BookInfo.objects.all()</span><br><span class="line">    HeroInfo.objects.all()</span><br><span class="line">    </span><br><span class="line">7）查询出id为2的图书中所有英雄人物的信息。</span><br><span class="line">    b &#x3D; BookInfo.objects.get(id&#x3D;2)</span><br><span class="line">    b.heroinfo_set.all() #查询出b图书中所有英雄人物的信息</span><br></pre></td></tr></table></figure>
<p><strong>多类之间的关系</strong><br><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%876.jpg" alt="1"></p>
<hr>
<h2 id="后台管理"><a href="#后台管理" class="headerlink" title="后台管理"></a>后台管理</h2><ol>
<li>本地化</li>
</ol>
<p>进行语言和时区的本地化</p>
<p>修改settings.py文件。<br><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%877.png" alt="1"></p>
<ol start="2">
<li>创建管理员<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure></li>
<li>注册模型类</li>
</ol>
<p>在应用下的admin.py中注册模型类。<br>告诉djang框架根据注册的模型类来生成对应表管理页面。<br><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%878.png" alt="1"></p>
<hr>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>在Django中，通过浏览器去请求一个页面时，使用视图函数来处理这个请求的，视图函数处理之后，要给浏览器返回页面内容。</strong></p>
<h3 id="视图函数的使用"><a href="#视图函数的使用" class="headerlink" title="视图函数的使用"></a>视图函数的使用</h3><ul>
<li>定义视图函数</li>
</ul>
<p><strong>视图函数定义在views.py中。</strong><br>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    #  进行处理</span><br><span class="line">    return HttpResponse(&#39;hello python&#39;)</span><br></pre></td></tr></table></figure>
<p>视图函数必须有一个参数request，进行处理之后，需要返回一个HttpResponse的类对象，hello python就是返回给浏览器显示的内容。</p>
<ul>
<li>进行URL配置</li>
</ul>
<p>url配置的目的是让建立url和视图函数的对应关系。</p>
<p>url配置项定义在urlpatterns的列表中，每一个配置项都调用url函数。</p>
<p>url函数有两个参数，第一个参数是一个正则表达式，第二个是对应的处理动作。</p>
<p>配置url时，有两种语法格式：</p>
<ol>
<li>url(正则表达式，视图函数名)</li>
<li>url(正则表达式，include(应用中的urls文件))</li>
</ol>
<p><strong>实际在配置url时，首先在项目的urls.py文件中添加配置项时，并不写具体的url和视图函数之间的对应关系，而是包含具体应用的urls.py文件，在应用的urls.py文件中写url和视图函数的对应关系。</strong></p>
<p>URL配置方式<br><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%879.png" alt="1"></p>
<h3 id="URL的匹配过程"><a href="#URL的匹配过程" class="headerlink" title="URL的匹配过程"></a>URL的匹配过程</h3><p><strong>在项目的urls.py文件中包含具体应用的urls.py文件，应用的urls.py文件中写url和视图函数的对应关系。</strong></p>
<h3 id="匹配方式和运行机制"><a href="#匹配方式和运行机制" class="headerlink" title="匹配方式和运行机制"></a>匹配方式和运行机制</h3><p><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%8710.png" alt="1"></p>
<p>当用户输入如<a href="http://127.0.0.1:8000/aindex时，" target="_blank" rel="noopener">http://127.0.0.1:8000/aindex时，</a> <strong>去除域名和最前面的/，剩下aindex，拿aindex字符串到项目的urls文件中进行匹配，配置成功之后，去除匹配的a字符，那剩下的index字符串继续到项目的urls文件中进行正则匹配，匹配成功之后执行视图函数index</strong> ，index视图函数返回内容hello python给浏览器来显示。</p>
<hr>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><em>不仅仅是一个HTML文件</em></p>
<h3 id="模板文件的使用"><a href="#模板文件的使用" class="headerlink" title="模板文件的使用"></a>模板文件的使用</h3><ol>
<li>创建模板文件夹(templates文件夹)</li>
<li>配置模板目录</li>
</ol>
<p><strong>在项目文件中修改settings文件，将其TEMPLATES下的’DIRS’改为[os.path.join(BASE_DIR, ‘templates’)]</strong></p>
<p><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%8711.png" alt="1"></p>
<p>其中BASE_DIR是项目的绝对路径</p>
<ol start="3">
<li>使用模板文件</li>
</ol>
<p><strong>在templates文件夹下建立与应用同名的文件夹，防止混淆</strong></p>
<ul>
<li>加载模板文件</li>
</ul>
<p>在模板目录下面获取HTML文件的内容，得到一个模板对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.templates import loader</span><br><span class="line">temp &#x3D; loader.get_template(&#39;相对于templates文件的相对路径&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>定义模板上下文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.templates import RequestContext</span><br><span class="line">context &#x3D; RequestContext(request, &#123;一个字典，替代模板中变量的值&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>向模板文件中传递数据</p>
<ul>
<li>模板渲染</li>
</ul>
<p>得到一个标准的HTML文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res_html &#x3D; temp.render(context)    # 渲染完成的HTML内容</span><br><span class="line">return HttpResponse(res_html)</span><br></pre></td></tr></table></figure>

<p><strong>以上三点在Django内部已经进行了封装，可直接调用render函数返回</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return render(request, &#39;相对于templates文件的相对路径&#39;, &#123;一个字典，替代模板中变量的值&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="在模板文件中定义变量"><a href="#在模板文件中定义变量" class="headerlink" title="在模板文件中定义变量"></a>在模板文件中定义变量</h3><ol>
<li>模板变量的使用 ： </li>
<li>for循环的使用 ： {% for i in list %}

</li>
</ol>
{% empty %}   # 当for循环中没有任何变量时显示的数据

{% endfor %}

<hr>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="Django-ORM"><a href="#Django-ORM" class="headerlink" title="Django ORM"></a>Django ORM</h3><p><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%8712.png" alt="1"></p>
<p><strong>O：(objects)-&gt;类和对象。</strong><br><br><strong>R：(Relation)-&gt;关系，关系数据库中的表格。</strong><br><br><strong>M：（Mapping）-&gt;映射。</strong></p>
<h3 id="Django-ORM-框架的功能"><a href="#Django-ORM-框架的功能" class="headerlink" title="Django ORM 框架的功能"></a>Django ORM 框架的功能</h3><ol>
<li>建立模型类和表之间的对应关系，允许我们通过面向对象的方式操作数据库</li>
<li>根据设计的模型类生成数据库的表格</li>
<li>通过方便的配置就可以进行数据库的切换</li>
</ol>
<p><em>在此之前使用的数据库都是Django默认的sqlite数据库，接下来我们将对Django配置进行修改，改为熟悉的MySQL数据库</em></p>
<h3 id="MySQL数据库配置"><a href="#MySQL数据库配置" class="headerlink" title="MySQL数据库配置"></a>MySQL数据库配置</h3><p><strong>修改settings.py中的DATABASES。</strong><br><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%8713.png" alt="1"><br><strong><em>注意：django框架不会自动帮我们生成mysql数据库，所以我们需要自己去创建。</em></strong></p>
<p><strong>切换mysql数据库之后不能启动服务器：</strong><br><br>安装mysqlPython包: <br><br>python2：<br>  pip install mysql-python<br><br>python3:<br>安装pymysql:<br>  pip install pymysql<br><br>在test1/<strong>init</strong>.py中加如下内容：<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<p>进行如上操作之后便完成了MySQL数据库的配置！</p>
<p><img src="/2019/07/23/Django/%E6%96%97%E5%9B%BE3.jpg" alt="1"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>最后在讲解一下重定向，当浏览器点击某一功能时，仍需要返回原网址。则需使用重定向。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return HttpResponseRedirect(&#39;&#x2F;当前网址&#39;)</span><br><span class="line"></span><br><span class="line">from django.shortcuts import redirct</span><br><span class="line">return redirect(&#39;&#x2F;当前网址&#39;)    # 使用Django中封装好的重定向函数redirect返回</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字段属性和选项"><a href="#字段属性和选项" class="headerlink" title="字段属性和选项"></a>字段属性和选项</h2><p><strong>属性命名限制：</strong></p>
<ol>
<li>不能是python的保留关键字。</li>
<li>不允许使用连续的下划线，这是由django的查询方式决定的。</li>
<li>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：<br>属性名=models.字段类型(选项)</li>
</ol>
<h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p><strong>使用时需要引入django.db.models包</strong>，字段类型如下：<br><br><strong>AutoField</strong>：自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性。<br><br><strong>BooleanField</strong>：布尔字段，值为True或False。<br><br><strong>NullBooleanField</strong>：支持Null、True、False三种值。<br><br><strong>CharField(max_length=字符长度)</strong>：字符串。<br>参数max_length表示最大字符个数。<br><br><strong>TextField</strong>：大文本字段，一般超过4000个字符时使用。<br><br><strong>IntegerField</strong>：整数。<br><br><strong>DecimalField(max_digits=None, decimal_places=None)</strong>：十进制浮点数。<br>参数max_digits表示总位数。<br>参数decimal_places表示小数位数。<br><br><strong>FloatField</strong>：浮点数。<br><br><strong>DateField([auto_now=False, auto_now_add=False])</strong>：日期。<br><br><em>参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为false。</em><br><br><em>参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false。</em><br><br><strong>参数auto_now_add和auto_now是相互排斥的，组合将会发生错误。</strong><br><br><strong>imeField</strong>：时间，参数同DateField。<br><br><strong>DateTimeField</strong>：日期时间，参数同DateField。<br><br><strong>FileField</strong>：上传文件字段。<br><br><strong>ImageField</strong>：继承于FileField，对上传的内容进行校验，确保是有效的图片。<br></p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p><strong>通过选项实现对字段的约束，选项如下</strong>：<br><br><strong>null</strong>：如果为True，表示允许为空，默认值是False。<br><br><strong>blank</strong>：如果为True，则该字段允许为空白，默认值是False。<br><br><strong><em>对比：null是数据库范畴的概念，blank是表单验证证范畴的。</em></strong><br><br><strong>db_column</strong>：字段的名称，如果未指定，则使用属性的名称。<br><br><strong>db_index</strong>：若值为True, 则在表中会为此字段创建索引，默认值是False。<br><br><strong>default</strong>：默认值。<br><br><strong>primary_key</strong>：若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用。<br><br><strong>unique</strong>：如果为True, 这个字段在表中必须有唯一值，默认值是False。<br></p>
<hr>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查看MySQL的日志文件"><a href="#查看MySQL的日志文件" class="headerlink" title="查看MySQL的日志文件"></a>查看MySQL的日志文件</h3><ol>
<li>sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf <strong>68 69行 注释取消</strong></li>
<li>sudo service mysql restart 重启mysql服务</li>
<li>/var/log/mysql/mysql.log #mysql操作的记录文件。</li>
<li>sudo tail -f /var/log/mysql/mysql.log #实时查看mysql文件的内容。</li>
</ol>
<h3 id="查询MySQL数据库中数据的方法"><a href="#查询MySQL数据库中数据的方法" class="headerlink" title="查询MySQL数据库中数据的方法"></a>查询MySQL数据库中数据的方法</h3><p><strong>get()</strong>:返回表中满足条件的一条且只能有一条数据。<br><br>如果查到多条数据，则抛异常：MultipleObjectsReturned<br><br>查询不到数据，则抛异常：<br>DoesNotExist<br></p>
<p><strong>all()</strong>:返回模型类对应表格中的所有数据。QuerySet类型，查询集<br></p>
<p><strong>filter()</strong>:参数写查询条件，返回满足条件的数据。QuerySet<br><br><em>条件格式：模型类属性名__条件名=值</em></p>
<h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><ol>
<li><p>判等 exact。<br><br>例：查询编号为1的图书。<br><br>BookInfo.objects.get(id=1)<br><br>BookInfo.objects.get(id__exact=1)</p>
</li>
<li><p>模糊查询 contains<br><br>例：查询书名包含’传’的图书。<br><br>BookInfo.objects.filter(btitle__contains=’传’)<br><br>例：查询书名以’部’结尾的图书 endswith 开头:startswith<br><br>BookInfo.objects.filter(btitle__endswith=’部’)</p>
</li>
<li><p>空查询 isnull <em>(select * from booktest_bookinfo where title is not null)</em><br><br>例：查询书名不为空的图书。<br><br>BookInfo.objects.filte(btitle__isnull=False)</p>
</li>
<li><p>范围查询 in <em>(select * from booktest_bookinfo where id in (1,3,5))</em><br><br>例：查询编号为1或3或5的图书。<br><br>BookInfo.objects.filter(id__in = [1,3,5])</p>
</li>
<li><p>比较查询 <br><br>例：查询编号大于3的图书。gt(大于) lt(小于） gte(大于等于) lte(小于等于)<br><br>BookInfo.objects.filter(id__gt = 3)</p>
</li>
<li><p>日期查询<br><br>例：查询1980年发表的图书。<br><br>BookInfo.objects.filter(bpub_date__year=1980)<br><br>例：查询1980年1月1日后发表的图书。<br><br>from datetime import date<br>BookInfo.objects.filter(bpub_date__gt = date(1980,1,1))<br></p>
</li>
<li><p>exclude:返回不满足条件的数据。QuerySet<br><br>例：查询id不为3的图书信息。<br><br>BookInfo.objects.exclude(id=3)<br></p>
</li>
</ol>
<h3 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h3><p><strong>作用：用于类属性之间的比较条件。</strong><br><br>使用之前需要先导入：<br><br><strong>from django.db.models import F</strong><br><br>例：查询图书阅读量大于评论量图书信息。<br><br>BookInfo.objects.filter(bread__gt = F(‘bcomment’))<br><br>例：查询图书阅读量大于2倍评论量图书信息。<br><br>BookInfo.objects.filter(bread__gt = F(‘bcomment’)*2)</p>
<h3 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h3><p><strong>作用：用于查询时的逻辑条件。not and or，可以对Q对象进行&amp; | ~操作。</strong><br>使用之前需要先导入：<br><br><strong>from django.db.models import Q</strong><br><br>例：查询id大于3且阅读量大于30的图书的信息。<br><br>BookInfo.objects.filter(id__gt=3, bread__gt=30)<br><br>BookInfo.objects.filter(Q(id__gt=3)&amp;Q(bread__gt=30))<br><br>例：查询id大于3或者阅读量大于30的图书的信息。<br><br>BookInfo.objects.filter(Q(id__gt=3)|Q(bread__gt=30))<br><br>例：查询id不等于3图书的信息。<br><br>BookInfo.objects.filter(~Q(id=3))<br></p>
<h3 id="排序-order-by-QuerySet"><a href="#排序-order-by-QuerySet" class="headerlink" title="排序 order_by QuerySet"></a>排序 <strong>order_by</strong> QuerySet</h3><p><strong>作用：进行查询结果进行排序。</strong><br><br>例：查询所有图书的信息，按照id从小到大进行排序。<br><br>BookInfo.objects.all().order_by(‘id’)<br><br>BookInfo.objects.order_by(‘id’)<br><br>例：查询所有图书的信息，按照id从大到小进行排序。<br><br>BookInfo.objects.all().order_by(<strong>‘-id’</strong>)<br><br>例：把id大于3的图书信息按阅读量从大到小排序显示；<br><br>BookInfo.objects.filter(id__gt=3).order_by(‘-bread’)</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>作用：对查询结果进行聚合操作。</strong><br><br><strong>sum count max min avg</strong><br><br><strong>aggregate</strong>：调用这个函数来使用聚合。 返回值是一个字典<br><br>使用前需先导入聚合类： <br><br><strong>from django.db.models import Sum,Count,Max,Min,Avg</strong><br><br>例：查询所有图书的数目。Count<br><br>BookInfo.objects.aggregate(Count(‘id’))<br><br>返回值类型:<br>{‘id__count’: 5}<br><br>例：查询所有图书阅读量的总和。<br><br>BookInfo.objects.aggregate(Sum(‘bread’))<br><br>返回值类型：<br>{‘bread__sum’: 126}<br><br><strong>count函数 返回值是一个数字</strong><br><br><strong>作用：统计满足条件数据的数目。</strong><br><br>例：统计所有图书的数目。<br><br>BookInfo.objects.count()<br><br>例：统计id大于3的所有图书的数目。<br><br>BookInfo.objects.filter(id__gt=3).count()<br></p>
<p><strong>查询相关函数返回值总结：</strong><br><br><strong>get</strong>:返回一个对象 <br><br><strong>all</strong>:QuerySet 返回所有数据<br><br><strong>filter</strong>:QuerySet 返回满足条件的数据<br><br><strong>exclude</strong>:QuerySet 返回不满条件的数据 <br><br><strong>order_by</strong>:QuerySet 对查询结果进行排序<br><br><strong>aggregate</strong>:字典 进行聚合操作<br><br><strong>count</strong>:数字 返回查询集中数据的数目<br><br>get,filter,exclude参数中可以写查询条件。<br></p>
<h3 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h3><p><strong>all, filter, exclude, order_by调用这些函数会产生一个查询集，可以在查询集上继续调用这些函数。</strong><br>查询集特性：</p>
<ol>
<li>惰性查询：只有在实际使用查询集中的数据的时候才会发生对数据库的真正查询。</li>
<li>缓存：当使用的是同一个查询集时，第一次的时候会发生实际数据库的查询，然后把结果缓存起来，之后再使用这个查询集时，使用的是缓存中的结果。<br>限制查询集：<br></li>
</ol>
<p><strong>可以对一个查询集进行取下标或者切片操作来限制查询集的结果。</strong><br><br>b[0]就是取出查询集的第一条数据，b[0:1].get()也可取出查询集的第一条数据。如果b[0]不存在，会抛出IndexError异常，如果b[0:1].get()不存在，会抛出DoesNotExist异常。多条时抛MultiObjectsReturned异常<br>对一个查询集进行切片操作会产生一个新的查询集，下标不允许为负数。<br><br><strong>exists</strong>:判断一个查询集中是否有数据。(True False)</p>
<hr>
<h2 id="模型类关系"><a href="#模型类关系" class="headerlink" title="模型类关系"></a>模型类关系</h2><h3 id="三种关系模式"><a href="#三种关系模式" class="headerlink" title="三种关系模式"></a>三种关系模式</h3><ol>
<li>一对多关系<br><br>例：图书类-英雄类<br>models.ForeignKey() 定义在多的类中。</li>
<li>多对多关系<br><br>例：新闻类-新闻类型类 体育新闻 国际<br><br>models.ManyToManyField() 定义在哪个类中都可以。</li>
<li>一对一关系<br><br>例：员工基本信息类-员工详细信息类<br><br>models.OneToOneField() 定义在哪个类中都可以。<h3 id="关联查询-一对多"><a href="#关联查询-一对多" class="headerlink" title="关联查询(一对多)"></a>关联查询(一对多)</h3></li>
</ol>
<p><strong>在一对多关系中，一对应的类我们把它叫做一类，多对应的那个类我们把它叫做多类，我们把多类中定义的建立关联的类属性叫做关联属性。</strong><br><br>例：查询图书id为1的所有英雄的信息。<br><br>    book = BookInfo.objects.get(id=1)<br><br>    book.heroinfo_set.all()<br><br>通过模型类查询：<br><br>    <strong>HeroInfo.objects.filter(hbook_id=1)</strong><br><br>例：查询id为1的英雄所属图书信息。<br><br>    hero =HeroInfo.objects.get(id=1)<br><br>    hero.hbook<br><br>通过模型类查询：<br><br>    <strong>BookInfo.objects.filter(heroinfo__id=1)</strong><br><br>    <img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%876.jpg" alt="1"><br><strong>由一类的对象查询多类的时候：</strong><br><br>    一类的对象.多类名小写_set.all() #查询所用数据<br><br><strong>由多类的对象查询一类的时候：</strong><br><br>    多类的对象.关联属性  #查询多类的对象对应的一类的对象<br><br><strong>由多类的对象查询一类对象的id时候：</strong><br><br>    多类的对象. 关联属性_id<br><br><strong><em>通过模型类实现关联查询：</em></strong><br><br>例：查询图书信息，要求图书中英雄的描述包含’八’。<br><br>BookInfo.objects.filter(heroinfo__hcomment__contains=’八’)<br><br>例：查询图书信息，要求图书中的英雄的id大于3.<br><br>BookInfo.objects.filter(heroinfo__id__gt=3)<br><br>例：查询书名为“天龙八部”的所有英雄。<br><br>HeroInfo.objects.filter(hbook__btitle=’天龙八部’)<br><br><strong>通过多类的条件查询一类的数据：</strong><br><br>    一类名.objects.filter(多类名小写<strong>多类属性名</strong>条件名) <br><br><strong>通过一类的条件查询多类的数据：</strong><br><br>    多类名.objects.filter(关联属性<strong>一类属性名</strong>条件名)<br></p>
<h3 id="插入，更新和删除"><a href="#插入，更新和删除" class="headerlink" title="插入，更新和删除"></a>插入，更新和删除</h3><p>  调用一个模型类对象的save方法的时候就可以实现对模型类对应数据表的插入和更新。<br><br>调用一个模型类对象的delete方法的时候就可以实现对模型类对应数据表数据的删除。</p>
<h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><p><strong>自关联是一种特殊的一对多的关系。即在一个表中建立外键。</strong><br><br>注：mysql终端中批量执行sql语句：source areas.sql;</p>
<h3 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h3><p>在查询语句中都会使用到<strong>类名.objects.方法</strong>，那么objects是什么呢？<br><br>objects是Django帮我自动生成的管理器对象，通过这个管理器可以实现对数据的查询。<br><br>objects是models.Manger类的一个对象。自定义管理器之后Django不再帮我们生成默认的objects管理器。</p>
<ol>
<li>自定义一个管理器类，这个类继承models.Manger类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BookInfoManager(models.Manager):</span><br></pre></td></tr></table></figure></li>
<li>再在具体的模型类里定义一个自定义管理器类的对象。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object &#x3D; 自定义的管理器类()</span><br></pre></td></tr></table></figure>
自定义管理器类的应用场景：</li>
<li>改变查询的结果集。<br>比如调用BookInfo.books.all()返回的是没有删除的图书的数据。</li>
<li>添加额外的方法。<br>管理器类中定义一个方法帮我们创建对应的模型类对象。<br>使用self.model()就可以创建一个跟自定义管理器对应的模型类对象。</li>
</ol>
<p><img src="/2019/07/23/Django/Django%E5%AD%A6%E4%B9%A0%E5%9B%BE%E7%89%8714.png" alt="1"></p>
<h3 id="元选项"><a href="#元选项" class="headerlink" title="元选项"></a>元选项</h3><p>Django默认生成的表名：<br><br>    <strong>应用名小写_模型类名小写。</strong><br><br>元选项：<br><br>需要在模型类中定义一个元类Meta,在里面定义一个类属性db_table就可以指定表名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Meta:</span><br><span class="line">    db_table &#x3D; &#39;表名&#39;</span><br></pre></td></tr></table></figure>














]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础</title>
    <url>/2020/07/23/Go%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Python中不同赋值形式的差异</title>
    <url>/2020/04/07/Python%E4%B8%AD%E4%B8%8D%E5%90%8C%E8%B5%8B%E5%80%BC%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<h1 id="Python中的不同传递形式的差异"><a href="#Python中的不同传递形式的差异" class="headerlink" title="Python中的不同传递形式的差异"></a>Python中的不同传递形式的差异</h1><p>先来看一到题，题目是：给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。<br>不占用额外内存空间能否做到？</p>
<a id="more"></a>

<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
<p><strong>下面给出其中一种解法的两段Python3代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Code1</span><br><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix):</span><br><span class="line">        matrix &#x3D; list(zip(*matrix[::-1]))</span><br><span class="line"></span><br><span class="line">## Code2</span><br><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix):</span><br><span class="line">        matrix[:] &#x3D; list(zip(*matrix[::-1]))</span><br></pre></td></tr></table></figure>
<p>在研究两段代码区别之前，先来了解一下Python关于拷贝的一些坑。</p>
<h2 id="深拷贝、浅拷贝、赋值、切片"><a href="#深拷贝、浅拷贝、赋值、切片" class="headerlink" title="深拷贝、浅拷贝、赋值、切片"></a>深拷贝、浅拷贝、赋值、切片</h2><p>研究下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [1, 2, [&#39;a&#39;,3], &quot;asd&quot;, [5, 10, 15]]</span><br><span class="line">a_fuzhi &#x3D; a </span><br><span class="line">a_copy &#x3D; a.copy()</span><br><span class="line">a_deepcopy &#x3D; copy.deepcopy(a)</span><br><span class="line">a_slice &#x3D; a[:]</span><br><span class="line"></span><br><span class="line">## 当修改a时，四种引用方式会发生不同的效果</span><br><span class="line">a[0] &#x3D; 100</span><br><span class="line">a[2][1] &#x3D; 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:a_fuzhi&#x3D;[100, 2, [&#39;a&#39;, 100], &#39;asd&#39;, [5, 10, 15]]</span><br><span class="line">a_copy&#x3D;[1, 2, [&#39;a&#39;, 100], &#39;asd&#39;, [5, 10, 15]]</span><br><span class="line">a_deepcopy&#x3D;[1, 2, [&#39;a&#39;, 3], &#39;asd&#39;, [5, 10, 15]]</span><br><span class="line">a_slice&#x3D;[1, 2, [&#39;a&#39;, 100], &#39;asd&#39;, [5, 10, 15]]</span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以看出，<strong>在Python中只有深拷贝是将原来的全部数据重新放到一个新的内存地址中。</strong>而浅拷贝和切片都和原数据有关联，<strong>当改变父级数据是他们不会改变，但改变子数据时，他们也会随之改变。</strong>，对于赋值操作而言，只是增加了一个对原数据的指针(相当于起了一个别名)。</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="left">a_fuzhi</th>
<th align="center">a_copy</th>
<th align="center">a_deepcopy</th>
<th align="center">a_slice</th>
</tr>
</thead>
<tbody><tr>
<td align="center">parent</td>
<td align="left">true</td>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">children</td>
<td align="left">true</td>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">true</td>
</tr>
</tbody></table>
<p>那么回过头来看开头的那个问题，因为要求不占用其他内存，所以函数使用了<strong>原地处理</strong>,故没有返回值。在第一种方式中，<strong>matrix相当于只是函数中的一个变量</strong>，在函数调用结束时便会被回收；第二种方式中，<code>matrix[:]</code>利用了切片对解包压缩后的数据进行了拷贝，最终输出正确的结果。</p>
<p>个人能力有限，若有描述不当的地方，请多多包涵。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip报错</title>
    <url>/2021/05/21/pip%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h2 id="pip-升级时报错"><a href="#pip-升级时报错" class="headerlink" title="pip 升级时报错"></a>pip 升级时报错</h2><h1 id="当pip升级后，出现pip不能使用的问题"><a href="#当pip升级后，出现pip不能使用的问题" class="headerlink" title="当pip升级后，出现pip不能使用的问题"></a>当pip升级后，出现pip不能使用的问题</h1><h1 id="报错内容：sys-stderr-write-f“ERROR-exc-“"><a href="#报错内容：sys-stderr-write-f“ERROR-exc-“" class="headerlink" title="报错内容：sys.stderr.write(f“ERROR: {exc}“)"></a>报错内容：sys.stderr.write(f“ERROR: {exc}“)</h1><p>解决方案：在linux命令行下运行如下命令：</p>
<ol>
<li>curl <a href="https://bootstrap.pypa.io/2.7/get-pip.py" target="_blank" rel="noopener">https://bootstrap.pypa.io/2.7/get-pip.py</a> –output get-pip.py</li>
<li>python3 get-pip.py</li>
</ol>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客之搭建</title>
    <url>/2020/04/29/hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="hexo博客搭建-无坑版"><a href="#hexo博客搭建-无坑版" class="headerlink" title="hexo博客搭建-无坑版"></a>hexo博客搭建-无坑版</h1><blockquote>
<blockquote>
<p><strong>本文基于ubantu16.04下操作</strong></p>
</blockquote>
</blockquote>
<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><a id="more"></a>
<ul>
<li><p>通过包管理器安装,这里附上<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a><br><br>通过如下命令安装<br><br><code>sudo apt-get install git</code><br></p>
</li>
<li><p><em>注：通过这种⽅式安装的 Git 可能不是较新版的 Git，不过⼀般来说是够⽤的*</em></p>
</li>
<li><p>查看git是否安装成功<br><br><code>git --version</code><br><br><img src="/2020/04/29/hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%AD%E5%BB%BA/%E6%9F%A5%E7%9C%8Bgit%E7%89%88%E6%9C%AC.jpg" alt="查看git版本"></p>
</li>
</ul>
<h3 id="nodejs安装"><a href="#nodejs安装" class="headerlink" title="nodejs安装"></a>nodejs安装</h3><ol>
<li>进入<a href="https://nodejs.org/" target="_blank" rel="noopener">node官网</a>进行下载，默认保存在Downloads文件夹下。<br></li>
<li>在家目录下新建node文件夹并进入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir node</span><br><span class="line">cd node</span><br></pre></td></tr></table></figure></li>
<li>将下载的node-v12.18.2-linux-x64.tar.xz安装包解压到~/node 中<br><br><code>tar -xJvf ~/Downloads/node-v12.18.2-linux-x64.tar.xz</code><br></li>
</ol>
<p><strong>解压完成后，在~/node 目录下会出现一个node-v12.18.2-linux-x64的目录</strong><br>4. 配置node系统环境变量<br><br>编辑~/.bashrc 文件，在文件末尾追加如下信息<br><br><code>export PATH=/home/python/node/node-v12.18.2-linux-x64/bin:$PATH</code><br><br><img src="/2020/04/29/hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%AD%E5%BB%BA/node%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.jpg" alt="node"><br>5. 刷新环境变量，使其生效即可<br><br><code>source ~/.bashrc</code><br><br>6. 查看安装版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/29/hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%AD%E5%BB%BA/node%E7%89%88%E6%9C%AC%E6%9F%A5%E7%9C%8B.jpg" alt="node"></p>
<p><strong>至此准备工作就完成了，接下来就是hexo博客的安装啦！</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/29/hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%AD%E5%BB%BA/nice.jpg" alt="nice"></p>
<h2 id="hexo博客的安装"><a href="#hexo博客的安装" class="headerlink" title="hexo博客的安装"></a>hexo博客的安装</h2><ol>
<li>使用如下命令安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v #查看hexo版本</span><br></pre></td></tr></table></figure></li>
<li>新建一个blog文件夹（以后hexo博客的目录），并进入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure></li>
<li>初始化博客，启动本地博客，可在浏览器中查看<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo hexo init  #初始化博客</span><br><span class="line">hexo s  #启动本地博客</span><br></pre></td></tr></table></figure></li>
<li>启动之后就可以在本地的4000端口查看了<a href="http://localhost:4000/" target="_blank" rel="noopener">localhost</a></li>
<li>hexo的基本操作可以去官方文档查询（(hexo)[<a href="https://hexo.io/]）,下面创建一片新博文，并生成查看" target="_blank" rel="noopener">https://hexo.io/]）,下面创建一片新博文，并生成查看</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n 第一篇博文   # 创建一篇博文</span><br><span class="line">hexo clean    # 清理hexo缓存</span><br><span class="line">hexo g     # hexo生成</span><br><span class="line">hexo s     # 本地查看</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>此时就可以看到刚才新建的博文了</strong><br>6. 部署到GitHub<br><strong>现在博客只能本地查看，可以利用GitHub部署到远端，外网就可以查看了</strong><br></p>
<ul>
<li>如果没有GitHub账号的话，先注册一哈（<a href="https://github.com/" target="_blank" rel="noopener">github</a>）</li>
<li>在GitHub上创建一个新的仓库，名为 yourname.github.io (<strong>必须为这个名字</strong>)</li>
<li>下载Git部署插件<br><code>npm install --save hexo-deployer-git</code></li>
<li>在blog文件夹下找到_config.yml配置文件，在文件的最后修改成如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;YourGithubName&#x2F;YourGithubName.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li>
<li><em>其中repo为GitHub新建仓库的链接，并且：后有一个空格*</em></li>
<li>将本地的hexo博客部署到远端<br><code>hexo d</code><br></li>
<li><a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> #访问这个地址可以查看博客*</li>
</ul>
<p>如此操作成功之后，博客就搭建完成了，至于美化博客和文章写作就各显神通啦。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/29/hexo%E5%8D%9A%E5%AE%A2%E4%B9%8B%E6%90%AD%E5%BB%BA/%E5%8A%A0%E6%B2%B9.jpg" alt="加油"><br><br>（配置时如有问题可以联系博主，也可以在下方留言。）</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础</title>
    <url>/2020/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><h2 id="当今互联网基石——TCP-IP协议栈"><a href="#当今互联网基石——TCP-IP协议栈" class="headerlink" title="当今互联网基石——TCP/IP协议栈"></a>当今互联网基石——TCP/IP协议栈</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。并且，TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。</p>
<a id="more"></a>
<p><a href="https://baike.baidu.com/item/TCP/IP%E5%8D%8F%E8%AE%AE/212915" target="_blank" rel="noopener">百度百科</a></p>
<hr>
<h2 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP被称为是面向连接的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即必须相互发送某些预备报文，以建立确保函数传输的参数。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;TCP连接提供的是<strong>全双工服务</strong>：如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就可以在从进程B流向进程A的同时，也从进程A流向进程B。TCP连接也是点对点的连接，即在一次单个发送方与单个接收方的连接。</p>
<hr>
<h2 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h2><p><img src="/2020/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84.jpg" alt="1"><br><br>源端口号：发送方的端口号<br><br>目的端口号：接收方端口号<br><br>序号：该报文段的字节流编号<br><br>确认号：发送方期望从接收方收到的序号<br><br>首部长度：指示了32字节的首部长度，由于选项长度是不定的，当选项长度为0时，首部长度为20字节<br><br>接收窗口：用于流量控制，指示接收方愿意接受的字节数量<br><br>检验和：提供了差错检验功能<br><br>紧急数据指针：指出紧急数据<br><br>选项：用于发送方和接收方协商最大报文段长度时，或在高速网络环境下用作窗口调节因子时使用<br><br>数据：应用层数据<br></p>
<hr>
<h2 id="TCP连接控制-三次握手-四次挥手"><a href="#TCP连接控制-三次握手-四次挥手" class="headerlink" title="TCP连接控制(三次握手/四次挥手)"></a>TCP连接控制(三次握手/四次挥手)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP作为可靠数据连接，其连接机制起着至关作用。<br></p>
<h3 id="三次握手TCP连接机制"><a href="#三次握手TCP连接机制" class="headerlink" title="三次握手TCP连接机制"></a>三次握手TCP连接机制</h3><ol>
<li><p>客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不含有应用层的数据，但是在首部中的一个标志位(即<strong>SYN比特</strong>)被置为1。因此这个特殊的报文段被称为SYN报文段。另外，客户端会随机选择一个初始序号(client_isn)，并将此编号放置于该起始的TCP SYN报文段的序号字段。该报文段会被封装到一个IP数据报中，并发送给服务器。</p>
</li>
<li><p>一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，<strong>为该TCP连接分配TCP缓存和变量</strong>，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含任何的应用层数据。但是，在该报文段的首部包含着三个重要的信息。a：<strong><em>SYN比特被置为1</em></strong>；b：<strong><em>首部确认号字段被置为client_isn+1</em></strong>；c：<strong><em>服务器选择自己的初始序号(server_isn)，并将其放置到TCP报文段首部的序号字段中。</em></strong>该允许连接的报文段称为SYNACK报文段。</p>
</li>
<li><p>在客户端收到SYNACK报文段后，客户也要为该链接分配缓存和变量。客户主机接着向服务器发送另外一个报文段，最后一个报文段对服务器的允许连接的报文段进行了确认，将确认号字段置为server_isn+1。此时连接已经建立，所以<strong>将SYN比特置为0</strong>。该三次握手的第三个阶段(此阶段)可以在报文段负载中携带客户到服务器的数据。<br><br><img src="/2020/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="1"></p>
</li>
</ol>
<h3 id="四次挥手TCP断开机制"><a href="#四次挥手TCP断开机制" class="headerlink" title="四次挥手TCP断开机制"></a>四次挥手TCP断开机制</h3><ol>
<li><p>客户应用进程发出一个关闭命令。这会引起客户TCP向服务器进程发送一个特殊的TCP报文段。<strong>这个特殊的报文段让其首部中的FIN比特被置为1。</strong></p>
</li>
<li><p>当服务器接收到该报文段后，返回一个确认报文段。</p>
</li>
<li><p>当服务器发送给客户端的最后一个报文段发送完成后，发送终止报文段，<strong>此报文段中的FIN比特被置为1。</strong></p>
</li>
<li><p>客户端接受到终止报文段之后，对服务器TCP返回确认报文，<strong>并进入到TIME_WAIT状态</strong>(典型值为一分钟或两分钟)，该状态的目的是为了确保确认报文成功送达到服务器端。<br><br><img src="/2020/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="1"></p>
</li>
</ol>
<hr>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP为什么需要流量控制：<strong><em>对接收方缓存区的溢出而采取的措施。</em></strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;TCP通过让发送方维护一个称为<strong>接收窗口</strong>的变量来提供流量控制。通俗来说：接收窗口用于给发送方一个指示——接收方还有多少可用的缓存空间。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;通过下面这个例子来详细了解一下TCP的流量控制。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;假设主机A通过一条TCP连接向主机B发送一个大文件，主机B上为该链接分配了一个接受缓存，并用RcvBuffer来表示其大小。主机B上的应用从TCP缓存区读取数据时，定义以下变量：LastByteRead(主机B上的应用进程从缓存读出的数据流的最后一个字节的编号)，LastByteRcvd(从网络中到达的并且已经放入主机B接受缓存中的数据流的最后一个字节的编号)。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;由于TCP不允许已分配的缓存溢出，则有下式成立：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LastByteRcvd&nbsp;-&nbsp;LastByteRead &nbsp;&lt;=&nbsp; RcvBuffer<br><br>&nbsp;&nbsp;&nbsp;&nbsp;接受窗口用rwnd表示，其大小由缓存可用空间的数量来设置：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwnd&nbsp;=&nbsp;RcvBuffer&nbsp;-&nbsp;[LastByteRcvd&nbsp;-&nbsp;LastByteRead]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;利用变量rwnd来控制流量服务。主机B通过把当前的rwnd值(开始时，主机B设定rwnd=RcvBuffer)放入发给主机A的报文段的接收窗口字段中，通知主机A它在该链接的缓存中还有多少可用空间。因此，主机A要轮流跟踪两个变量，LastByteSent和LastByteAcked，这两个变量的差值即为主机A发送到连接中但未被确认的数据量。通过将未确认的数据量控制在rwnd以内，就可以保证主机A不会使主机B的接收缓存溢出。所以主机A在连接的整个生命周期须保证：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LastByteSent&nbsp;-&nbsp;LastByteAcked&nbsp;&lt;=&nbsp;rwnd<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注：当主机B的接收缓存已满时，即rwnd为0，主机A继续发送只有一个字节的数据报文段，这些报文段将会被接收方确认，最终缓存区将开始清空，并且确认报文中将包含一个非0的rwnd值。</strong></p>
<hr>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP为什么需要拥塞控制：<strong><em>对IP网络的拥塞而采取的措施。</em></strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%80%E7%82%B9%E7%82%B9.jpg" alt="1"><br><br>&nbsp;&nbsp;&nbsp;&nbsp;TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向链接发送流量的速率。<br></p>
<ol>
<li>TCP发送方如何限制它向其连接发送流量的速率？<br><br>&nbsp;&nbsp;&nbsp;&nbsp;答：运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口(cwnd)。在一个发送方中未被确认的数据量不会超过cwnd和rwnd中的最小值，即LastByteSent&nbsp;-&nbsp;LastByteAcked&nbsp;&lt;=&nbsp;min{cwnd&nbsp;，&nbsp;rwnd}</li>
<li>TCP发送方如何感知从它到目的地之间的路径是否存在拥塞呢？<br><br>&nbsp;&nbsp;&nbsp;&nbsp;答：我们将TCP发送方的“丢包事件”定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。此时发送方就认为在该路径上出现了拥塞。注意到：当网络没有拥塞时，如果确认报文以相当慢的速率到达时，则该拥塞窗口将以相当慢的速率增加，另一方面，当确认报文以高速率到达时，拥塞窗口将迅速的增大，以使发送报文段的速率迅速增加。所以TCP被说成是<strong>自计时</strong>的。</li>
<li>当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢？<br><br>&nbsp;&nbsp;&nbsp;&nbsp;答：TCP通过<strong><em>TCP拥塞控制算法</em></strong>来控制其发送报文段的速率。该算法包括3个重要部分，分别为：慢启动；拥塞避免；快速恢复。<br></li>
</ol>
<ul>
<li>慢启动<br><br>当一条TCP连接开始时，cwnd通常初始置为一个MSS的较小值，这就使得初始的发送速率大约为MSS/RTT(RTT为传播时延)。在慢启动状态，cwnd的值以一个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。此时发送速率呈倍数增长，直到存在一个超市指示的丢包事件，<strong>TCP发送方将cwnd设置为1并重新开始慢启动过程，还将第二个状态变量的值ssthresh设置为cwnd/2，即当前检测到拥塞时将ssthresh置为拥塞窗口值的一半</strong>。当cwnd的值到达或超过ssthresh时，TCP转移到<strong>拥塞避免模式。</strong>第二种结束慢启动的方式为，<strong>当检测到三次冗余ACK时，TCP执行一种快速重传并进入快速恢复状态。</strong></li>
<li>拥塞避免<br><br>一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值得一半。<strong>每当新的确认报文到达时，就将cwnd的值增加一个MSS。</strong>(不同于慢启动状态下的翻倍增长)当发生超时时，cwnd的值被更新为1个MSS，ssthresh被置为cwnd的一半并进入<strong>慢启动状态</strong>。当发送端收到三次冗余ACK后，TCP将cwnd的值减半(一般置为cwnd/2+3MSS)，将ssthresh的值记录为cwnd值的一半，进入到<strong>快速恢复状态</strong>。</li>
<li>快速恢复<br><br>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到每个冗余ACK后，cwnd的值增加一个MSS。最终，当对丢失报文的ACK到达后，TCP在降低cwnd后进入<strong>拥塞避免状态</strong>。如果出现超时丢包事件，将cwnd的值置为1，ssthresh的值置为cwnd的一半，迁移到<strong>慢启动状态。</strong><br><br><img src="/2020/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.jpg" alt="对比"><br></li>
<li><strong>注：TCP拥塞控制常常被称为加性增，乘性减拥塞控制方式*</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%81%9C.jpg" alt="对比"><br></li>
</ul>
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
</search>
