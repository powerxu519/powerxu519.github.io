---
title: Python中不同赋值形式的差异
date: 2020-04-07 08:00:27
tags: python
---
# Python中的不同传递形式的差异
先来看一到题，题目是：给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。
不占用额外内存空间能否做到？
<!--more-->

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]

**下面给出其中一种解法的两段Python3代码：**
```
## Code1
class Solution:
    def rotate(self, matrix):
        matrix = list(zip(*matrix[::-1]))

## Code2
class Solution:
    def rotate(self, matrix):
        matrix[:] = list(zip(*matrix[::-1]))
```
在研究两段代码区别之前，先来了解一下Python关于拷贝的一些坑。

## 深拷贝、浅拷贝、赋值、切片
研究下面的代码：
```
a = [1, 2, ['a',3], "asd", [5, 10, 15]]
a_fuzhi = a 
a_copy = a.copy()
a_deepcopy = copy.deepcopy(a)
a_slice = a[:]

## 当修改a时，四种引用方式会发生不同的效果
a[0] = 100
a[2][1] = 100


out:a_fuzhi=[100, 2, ['a', 100], 'asd', [5, 10, 15]]
a_copy=[1, 2, ['a', 100], 'asd', [5, 10, 15]]
a_deepcopy=[1, 2, ['a', 3], 'asd', [5, 10, 15]]
a_slice=[1, 2, ['a', 100], 'asd', [5, 10, 15]]
```
通过上面的代码可以看出，**在Python中只有深拷贝是将原来的全部数据重新放到一个新的内存地址中。**而浅拷贝和切片都和原数据有关联，**当改变父级数据是他们不会改变，但改变子数据时，他们也会随之改变。**，对于赋值操作而言，只是增加了一个对原数据的指针(相当于起了一个别名)。

|type    | a_fuzhi  | a_copy   | a_deepcopy | a_slice |
|:------:|:---------|:--------:|:----------:|:-------:|
|parent  |   true   |   false  |    false   |   false |
|children|   true   |   true   |    false   |   true  |


那么回过头来看开头的那个问题，因为要求不占用其他内存，所以函数使用了**原地处理**,故没有返回值。在第一种方式中，**matrix相当于只是函数中的一个变量**，在函数调用结束时便会被回收；第二种方式中，`matrix[:]`利用了切片对解包压缩后的数据进行了拷贝，最终输出正确的结果。



个人能力有限，若有描述不当的地方，请多多包涵。